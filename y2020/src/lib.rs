pub mod day1 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day1.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day2 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day2.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day3 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day3.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day4 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day4.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day5 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day5.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day6 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day6.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day7 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day7.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day8 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day8.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day9 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day9.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day10 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day10.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day11 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day11.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day12 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day12.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day13 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day13.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day14 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day14.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day15 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day15.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day16 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day16.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day17 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day17.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day18 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day18.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day19 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day19.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day20 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day20.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}
pub mod day21 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day21.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day22 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day22.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day23 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day23.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day24 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day24.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}

pub mod day25 {
    pub type Int = u32;

    pub fn generator(input: &str) -> Vec<Int> {
        std::unimplemented!();
    }

    pub fn part1(input: &[Int]) -> Int {
        std::unimplemented!();
    }

    pub fn part2(input: &[Int]) -> usize {
        std::unimplemented!();
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use std::fs::read_to_string;

        const EXAMPLE: &str = "";

        #[test]
        #[ignore]
        fn test_part1() {
            let input = generator(EXAMPLE);
            assert_eq!(part1(&input), 7);
        }

        #[test]
        #[ignore]
        fn test_part2() {
            let input = generator(EXAMPLE);
            assert_eq!(part2(&input), 5);
        }

        #[test]
        #[ignore]
        fn test_answers() {
            let input_file = "../data/2021/day25.txt";
            let input_str =
                read_to_string(&input_file).expect(&format!("Input file {} not exist", input_file));
            let input = generator(&input_str);
            assert_eq!(part1(&input), 1448);
            assert_eq!(part2(&input), 1471);
        }
    }
}
